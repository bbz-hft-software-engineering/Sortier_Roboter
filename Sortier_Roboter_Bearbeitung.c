#pragma config(Sensor, S1,     Bump,           sensorEV3_Touch, modeEV3Bump)
#pragma config(Sensor, S2,     Touch,          sensorEV3_Touch)
#pragma config(Sensor, S3,     Color,          sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     Angle,          sensorEV3_Gyro)
#pragma config(Motor,  motorA,          engineA,       tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          engineB,       tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          SengineC,      tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main(){

	short currentColour;
	resetGyro(S4);
	while (true)
	{
		// Colours range from 0 to 7
		// None    = 0
		// Black   = 1
		// Blue    = 2
		// Green   = 3
		// Yellow  = 4
		// Red     = 5
		// White   = 6
		// Brown   = 7

	// Container Zuweisung nach Farbe des Pakets

	currentColour = SensorValue[Color];

		switch(currentColour)
		{
		case 0:
		displayCenteredBigTextLine(4, "none");

		break;

		case 1:
		displayCenteredBigTextLine(4, "black");

		break;

		case 2:
		displayCenteredBigTextLine(4, "blue");
			if (SensorValue(S2)==1){
	driveToGoal(9000)
		}
		break;

		case 3:
		displayCenteredBigTextLine(4, "green");
			if (SensorValue(S2)==1){
	driveToGoal(3000)
		}
		break;

		case 4:
		displayCenteredBigTextLine(4, "yellow");
			if (SensorValue(S2)==1){
	driveToGoal(6000)
		}
		break;

		case 5:
		displayCenteredBigTextLine(4, "red");
			if (SensorValue(S2)==1){
	driveToGoal(12000)
		}
		break;

		case 6:
		displayCenteredBigTextLine(4, "white");
			if (SensorValue(S2)==1){
	driveToGoal(15000)
		}
		break;

		case 7:
		displayCenteredBigTextLine(4, "brown");

		break;

		default: displayCenteredBigTextLine(4, "unknown");
		}

}

void driveToGoal(int time){

// Start --> Paket ausliefern und zurückfahren
		sleep(20);


		if ((currentColour == 3) && (SensorValue(S2)==1)){

			int startTime = time1[T1];
			while (time1[T1] - startTime < time) {
				setMotor(motorA,20);
				setMotor(motorB,20);

				if (SensorValue[S4]<-3){
					// Wenn der Sensorwert von Sensor 3 gleich 3 ist oder der Sensorwert von Sensor 4 kleiner als -3 ist
					setMotor(motorA,20);
					setMotor(motorB,-20);
				}

				else if(SensorValue[S4] > 3) {
					// Wenn der Sensorwert von Sensor 4 größer als 3 ist
					setMotor(motorA,-20);
					setMotor(motorB,20);
				}
			}
			//Fahrzeug dreht sich um 90 Grad
			repeatUntil(getGyroHeading(S4) == 80)
			{
				setMotor(motorA, 5);
				setMotor(motorB, -5);
			}
			stopMotor(motorA);
			stopMotor(motorB);

			//Drehung von Motor C um 90 Grad
			moveMotorTarget(motorD, 90, 10);
			sleep(1000);
			//Drehung von Motor C auf Ausgangsposition
			moveMotorTarget(motorD,90,-10);
			waitUntilMotorStop(motorD);

			// back to home
			// turn back
			repeatUntil(getGyroHeading(S4) == -5){
				setMotor(motorA, -5);
				setMotor(motorB, 5);
			}
			stopMotor(motorA);
			stopMotor(motorB);
			startTime = time1[T1];
			while	(time1[T1] - startTime < 5000) {
				setMotor(motorA,-20);
				setMotor(motorB,-20);
			}
			stopMotor(motorA);
			stopMotor(motorB);
}

	}
}
